---
title: "Analysis of Ecological Data <br> How to get functional traits?"
author: "<b>Markus Bauer</b> <br>"
date: today
date-format: iso
format: html
toc: true
toc-depth: 3
toc-expand: 2
number-sections: true
dev: png
fig-width: 7
fig-height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE
  )
```

Technichal University of Munich, TUM School of Life Sciences, Chair of
Restoration Ecology, Emil-Ramann-Straße 6, 85354 Freising, Germany

[markus1.bauer\@tum.de](mailto:markus1.bauer@tum.de)

<img src="https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png" alt="ORCID logo" width="20" height="20"/><https://orcid.org/0000-0001-5372-4174>

[![GoogleScholar](https://img.shields.io/badge/Google%20Scholar-4285F4?style=for-the-badge&logo=google-scholar&logoColor=white)](https://scholar.google.de/citations?user=oHhmOkkAAAAJ&hl=de&oi=ao)
[![GitHub](https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white)](https://github.com/markus1bauer)

::: {.content-hidden when-format="html"}

# Tasks

* Include Ellenberg values (see last point)
* Write learning objectives

:::

# Preparation

## Load libraries

You can always install missing libraries by `install.packages()` like `install.packages("here")`. We use the `tidyverse` package (Wickham et al. [2019](https://doi.org/10.21105/joss.01686)), the `GIFT` package (Denelle et al. [2023](https://doi.org/10.1111/2041-210X.14213)) and the package `TNRS` (Boyle et al.[2013](https://doi.org/10.1186/1471-2105-14-16))

```{r libraries, message = FALSE, results = FALSE}
library(here)
library(tidyverse)
library(GIFT)
library(TNRS)
rm(list = ls())
```

## The example data set

A study in the Ammer valley before and after the weir in the [floodplain Schnalz](https://www.openstreetmap.org/#map=16/47.7737/10.9615).

Normally there are alluvial grey alder forests (Alnetum incanae, alliance [Alnion incanae](https://floraveg.eu/vegetation/overview/Alnion%20incanae), EUNIS habitat [T12](https://floraveg.eu/habitat/overview/T12))

Due to the dam along the Ammer and the weir in the Ammer the flood regime changed and the vegetation could have developed to a maple-ash forest ('Edellaubholzwald') (Adoxo-Aceretum, alliance [Tilio-Acerion](https://floraveg.eu/vegetation/overview/Tilio-Acerion), EUNIS habitat type [T1F](https://floraveg.eu/habitat/overview/T1F%3E))

The dataset is also available on [Zenodo](https://doi.org/10.5281/zenodo.6054867) (Bauer et al. [2018](https://doi.org/10.14471/2018.38.006))

## Load data

```{r load-data}
species_ammer <- read_csv(
  here("data", "raw", "example_course_alluvial_forest_mb", "data_raw_species.csv"),
  col_names = TRUE, col_types = cols(.default = "?")
  ) %>%
  filter(layer == "h") %>% # select only the herbal layer, but not tree or shrub layer
  select(-layer)
```

<a href="#top">Back to top</a>

# Calculate traits from measured values

A short example how to calculate functional traits by your own. For example the specific leaf area (SLA) of trees ([*Acer platanoides*](https://floraveg.eu/taxon/overview/Acer%20platanoides) and [*Tilia cordata*](https://floraveg.eu/taxon/overview/Tilia%20cordata)) in a greenhouse experiment in Dürnast (Bauer et al. [2023](https://doi.org/10.1007/s00468-023-02391-8)).

Per tree, three leaves were chosen and the leaf area was measured and latter the dry weight (Perez-Harguindeguy et al. [2013](https://www.uv.es/jgpausas/papers/PerezHarguindeguy-2013-AJB_traits-handbook2.pdf), section 3.1).

```{r}
traits_bricks <- read_csv(
  here("data", "raw", "example_course_brick_trees_mb", "data_raw.csv"),
  col_names = TRUE, col_types = cols(.default = "?")
)

traits_bricks %>%
  select(plot, block, species, starts_with("leaf")) %>%
  head()
```

Divide the leaf area by the leaf mass:

```{r}
data <- traits_bricks %>%
  mutate(
    sla1 = leaf1Area / leaf1Mass,
    sla2 = leaf2Area / leaf2Mass,
    sla3 = leaf3Area / leaf3Mass,
    sla_mean = (sla1 + sla2 + sla3) / 3
  ) %>%
  select(1:3, 8, starts_with("leaf"), starts_with("sla"))
data %>%
  select(plot, species, starts_with("sla"))
```


<a href="#top">Back to top</a>

# Traits from databases

[Original vignette](https://biogeomacro.github.io/GIFT/articles/GIFT.html#trait-data) by Denelle & Weigelt (2024)

Get the functional trait values from the Global Inventory of Floras and Traits (GIFT) database (Weigelt et al. [2023](https://doi.org/10.1111/jbi.13623)) with the package `GIFT` (Denelle et al. [2023](https://doi.org/10.1111/2041-210X.14213)).

## Metadata of traits

There are many functional traits available in the GIFT database. Each of these traits has an identification number called `trait_ID`. Since the two functions for retrieving trait values, `GIFT_traits()` and `GIFT_traits_raw()`, rely on these IDs, the first step is to call the function `GIFT_traits_meta()` to know what the ID of the desired trait is. For example, let’s say we want to retrieve the maximum vegetative heights of plant species.

```{r select-plant-traits, message = FALSE}
trait_meta <- GIFT::GIFT_traits_meta()

trait_meta %>%
  filter(str_detect(Trait2, "height")) %>%
  select(-comment) %>%
  head(n = 10)
```

We can see that the ID of this trait is 1.6.2. Now that we have the ID, we can use `GIFT_traits()` to retrieve the growth form values for different plant species.

<a href="#top">Back to top</a>

## Get trait values

### Raw data and aggregated data

There are two functions to access trait values. First, `GIFT_traits_raw()` returns all trait values for a given species and a given trait. These trait values can then vary. Second, `GIFT_traits()` returns an aggregated trait value at the species level. The aggregation simply takes the mean for continuous traits or the most frequent entry for categorical traits. However, for some specific cases, the aggregation takes either the minimum or the maximum, as for the trait we chose. Let’s retrieve the raw and aggregated values for the maximum vegetative height of plants (trait_ID 1.6.2).

```{r download-traits-example, results = FALSE, message = FALSE}
height <- GIFT::GIFT_traits(
  trait_IDs = c("1.6.2"), agreement = 0.66, bias_ref = FALSE, bias_deriv = FALSE
  )

height_raw <- GIFT::GIFT_traits_raw(trait_IDs = c("1.6.2"))

height_raw %>% # Raw values
  select(work_species, trait_ID, trait_value) %>%
  filter(work_species == "Fagus sylvatica")

height %>% # Aggregated value
  filter(work_species == "Fagus sylvatica")
```

There were three maximum heights for Fagus sylvatica, 30, 35, and 50 meters, which led to an aggregated value of 50 meters.

<a href="#top">Back to top</a>

### Get the references of the measurements

If you want to look up the references that led to the aggregated trait value, you can run this chunk:

```{r trait-references, results = FALSE, message = FALSE}
references <- GIFT::GIFT_references(GIFT_version = "latest")

unique(unlist(strsplit(height$references_1.6.2, ",")))

references <- references[
  which(
    references$ref_ID %in% unique(
      unlist(strsplit(height$references_1.6.2, ","))
      )
    ), ]
references[1:2, ]
```

<a href="#top">Back to top</a>

### Download traits

Here is an example how to download several traits:

```{r get-traits, results = FALSE, message = FALSE}
trait_ids <- c(
  "1.2.2", "1.5.1", "1.6.3", "3.2.3", "3.3.1", "3.6.1", "3.7.1", "3.21.1",
  "4.1.3", "4.5.1"
  )

GIFT::GIFT_traits_meta() %>%
  filter(Lvl3 %in% trait_ids) # Get an overview of selected traits

data_gift <- GIFT::GIFT_traits(
  trait_IDs = trait_ids,
  agreement = 0.66, bias_ref = FALSE, bias_deriv = FALSE
  )
```

<a href="#top">Back to top</a>

# Name resolving

[Original vignette](https://cran.r-project.org/web/packages/TNRS/vignettes/TNRS_vignette.html) by Maitner (2024)

Use the Taxonomic Names Resolution Service ([TNRS](https://tnrs.biendata.org/)) with the package `TNRS` (Boyle et al.[2013](https://doi.org/10.1186/1471-2105-14-16)) for name resolving and the taxonoic resouces World Checklist of Vascular Plants of Kew Gardens (WCVP; Govaerts [2023](http://sftp.kew.org/pub/data-repositories/WCVP/)) and World Flora Online (WFO Consortium [2023](https://doi.org/10.5281/zenodo.8079052))

```{r resolve-names-species}
rm(list = setdiff(ls(), c("species_ammer", "traits_ammer", "data_gift")))
metadata <- TNRS::TNRS_metadata()

data <- species_ammer %>%
  rowid_to_column("id") %>%
  select(id, name) %>%
  TNRS::TNRS(
    sources = c("wcvp", "wfo"), # first use WCVP and alternatively WFO
    classification = "wfo", # family classification
    mode = "resolve"
  )

data_names <- data %>%
  select(
    Name_submitted, Taxonomic_status, Accepted_name, Accepted_name_url,
    Accepted_family
    ) %>%
  rename_with(tolower)
```

<a href="#top">Back to top</a>

# Merge TNRS names with species and traits table

Merge the resolved species names and the functional plant traits into the existing tables 'species' and create a new one 'traits'. First, you have to check for duplicates in the column 'accepted_name' created by name resolving. Second, summarize duplicates by summing the abundances.

```{r merge-resolved-names}
rm(list = setdiff(ls(), c("species_ammer", "data_names", "data_gift")))

data <- species_ammer %>%
  rename(name_submitted = name) %>%
  full_join(
    data_names %>% select(name_submitted, accepted_name), by = "name_submitted"
    )

data %>% filter(duplicated(accepted_name))

data2 <- data %>%
  group_by(accepted_name) %>%
  summarize(across(where(is.numeric), ~ sum(.x, na.rm = TRUE)))

data2 %>% filter(duplicated(accepted_name))

species_ammer <- data2

data3 <- data_names %>%
  select(accepted_name, accepted_name_url, accepted_family) %>%
  group_by(accepted_name) %>%
  slice(1) %>% # use only 1 row of accepted name (e.g. of Mentha aquatica)
  left_join(
    data_gift %>% rename(accepted_name = work_species), by = "accepted_name"
    )

traits_ammer <- data3 %>%
  select(starts_with("accepted_"), starts_with("trait_value")) %>%
  rename(
    growth_form_2 = trait_value_1.2.2,
    parasite_1 = trait_value_1.5.1,
    plant_height_mean = trait_value_1.6.3,
    seed_mass_mean = trait_value_3.2.3,
    dispersal_syndrome_1 = trait_value_3.3.1,
    pollination_syndrome_1 = trait_value_3.6.1,
    flowering_start = trait_value_3.7.1,
    flower_colour = trait_value_3.21.1,
    sla_mean = trait_value_4.1.3,
    nitrogen_fix_1 = trait_value_4.5.1
  )
```

<a href="#top">Back to top</a>

 
# Ellenberg indicator values

You can work with the classical Ellenberg indicator values (EIV) like with functional plant traits. Tichý et al. ([2023](https://doi.org/10.1111/jvs.13168)) provide European Ellenberg values on  on [FloraVeg.EU](https://floraveg.eu/download/) (file "Ellenberg-type indicator values"; also documented on [Zenodo](https://doi.org/10.5281/zenodo.7427088)). Use the sheet "Tab-OriginalNamesValues" and filter "Source = Ellenberg" to get the German EIV. If you analyse data across several European countries, you should load the sheet "Tab-IVs-Tichy-et-al2022".

This time we do not harmonize the 'traits_ellenberg' table with `TNRS`, but make to attempts to join and then we rename the species by hand.

```{r results = FALSE}
library(readxl)
traits_ellenberg <- readxl::read_excel(
  here("data", "raw", "Indicator_values_Tichy_et_al 2022-11-29.xlsx"),
  sheet = "Tab-OriginalNamesValues",
  col_names = TRUE
  ) %>%
  select(Taxon.Original, Taxon, Source, L, "T", M, R, N, S) %>%
  rename_with(tolower)

# Join with 'taxon.original'
data <- traits_ammer %>%
  select(accepted_name) %>%
  inner_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon.original) %>%
      filter(source == "Ellenberg") %>%
      select(-taxon),
    by = "accepted_name"
    )

# Join with 'taxon'
data2 <- traits_ammer %>%
  anti_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon.original) %>% # Which have no counterpart in 'traits_ellenberg$taxon.original'
      filter(source == "Ellenberg"),
    by = "accepted_name"
    ) %>%
  inner_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon) %>%
      filter(source == "Ellenberg") %>%
      select(-taxon.original),
    by = "accepted_name"
  )

data2 %>%
  filter(duplicated(accepted_name))

# Join with 'taxon' but account for duplicates
data3 <- traits_ammer %>%
  anti_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon.original) %>% # Which have no counterpart in 'traits_ellenberg$taxon.original'
      filter(source == "Ellenberg"),
    by = "accepted_name"
    ) %>%
  inner_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon) %>%
      filter(
        source == "Ellenberg" &
          !(taxon.original == "Pimpinella major ssp. rubra") #  avoid duplicate
        ) %>%
      select(-taxon.original),
    by = "accepted_name"
  )

missing_species <- traits_ammer %>%
  select(accepted_name) %>%
  anti_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon.original) %>% # Which have no counterpart in 'traits_ellenberg$taxon.original'
      filter(source == "Ellenberg"),
    by = "accepted_name"
    ) %>%
  anti_join(
    traits_ellenberg %>%
      rename(accepted_name = taxon) %>% # Which have neither a counterpart in 'traits_ellenberg$taxon'
      filter(source == "Ellenberg"),
    by = "accepted_name"
  )
```

From 'missing_species' you know the species which have no match in 'traits_ellenberg'. Therefore, you have to search this dataset by hand and rename the species names:

```{r results = FALSE}
data4 <- traits_ellenberg %>%
  mutate(
    taxon.original = factor(taxon.original),
    taxon.original = fct_recode(
      taxon.original,
      "Dryopteris carthusiana" = "Dryopteris carthusiana (spinulosa)",
      "Galium mollugo" = "Galium mollugo (elatum)",
      "Leucanthemum vulgare" = "Leucanthemum vulgare (leucanthem.)",
      "Myosotis scorpioides" = "Myosotis palustris (scorpioides)",
      "Rosa canina" = "Rosa canina agg.",
      "Senecio ovatus" = "Senecio fuchsii (ovatus)",
      "Valeriana excelsa subsp. excelsa" = "Valeriana procurrens (repens)",
      "Valeriana officinalis" = "Valeriana (exaltata)"
    )
  )
```

Now, we merge the datasets.

```{r}
data5 <- traits_ammer %>%
  inner_join(
    data4 %>% # Use data4 with renamed taxon names of column 'taxon.original'
      filter(source == "Ellenberg") %>%
      rename(accepted_name = taxon.original) %>%
      select(-taxon),
    by = "accepted_name"
    ) %>%
  bind_rows(data3) # Join with matched species of column 'taxon'

missing_completely <- traits_ammer %>%
  anti_join(data5, by = "accepted_name")

data6 <- data5 %>%
  bind_rows(missing_completely)

traits_ammer <- data6
```

<a href="#top">Back to top</a>

# Save

```{r save-files}
rm(list = setdiff(ls(), c("species_ammer", "traits_ammer")))
write_csv(
  species_ammer, here("data", "processed", "data_processed_species_ammer_4.1.csv")
  )
write_csv(
  traits_ammer, here("data", "processed", "data_processed_traits_ammer_4.1.csv")
  )
```

<a href="#top">Back to top</a>

# Tasks

* Select at least five functional plant traits.
* Note the categories, IDs, unit, and the version of the GIFT database for the material-and-methods section.
* Get aggregated trait values from the GIFT database

* Resolve names with TNRS
* Note the version of the database from `metadata$version` and the sources of the names with `metadata$citations` for the material-and-methods section
* Note the range of 'Overall_score' for your submitted species names.

```{r}
sessionInfo()
```
